# Auto-generated by setup_surface_kernel_py.py

pkgname = "linux-surface-generated"
pkgver = "6.14.2"
pkgrel = 1
pkgdesc = f"Linux kernel ({pkgver.split('.')[0]}.{pkgver.split('.')[1]} series) with Surface patches"
archs = ["x86_64"]  # Assuming x86_64 as per typical Surface devices
license = "GPL-2.0-only"
url = "https://github.com/linux-surface/linux-surface"

# Use a tarball archive of the specific git tag.
# _srctag_value will be substituted by the generator.
_srctag_for_archive = "v6.14.2-arch1"
# GitHub archives typically extract to <repo_name>-<tag_name_without_v_prefix>
# However, for the archlinux/linux repo, it seems to extract to just 'linux' + the commit hash or tag.
# Let's use the _srcname from PKGBUILD as a hint, which is 'archlinux-linux'.
# Or more generically, for github archives, it's often <repo_name>-<stripped_tag>
# As confirmed by user's `ls` output, cbuild's extract hook promotes the contents
# of the single root directory within the tarball (e.g., 'linux-6.14.2-arch1/')
# directly into self.srcdir.
# Therefore, build_wrksrc should NOT be set, so that operations in prepare()
# happen directly in self.srcdir, where Makefile, Kconfig, etc., are now located.

source = [
    f"https://github.com/archlinux/linux/archive/refs/tags/{_srctag_for_archive}.tar.gz>{pkgname}-{pkgver}-source.tar.gz"
]
# User will need to update this checksum after the first fetch.
sha256 = ["PLEASE_UPDATE_CHECKSUM_AND_REPLACE_THIS_STRING_WITH_THE_ACTUAL_SHA256"]

hostmakedepends = [
    "bc-gh", "libarchive", "gettext", "git", "elfutils-devel", "perl", "xz", "python",
    "base-kernel-devel", # Standard for Chimera kernel builds
]
depends = ["base-kernel"]
provides = [f"linux={pkgver.split('.')[0]}.{pkgver.split('.')[1]}"]

options = [
    "!check", "!debug", "!strip", "!scanrundeps", "!scanshlibs", "!lto",
    "textrels", "execstack", "foreignelf"
]

make_env = {
    "KBUILD_BUILD_HOST": "chimera-linux",
    "KBUILD_BUILD_USER": pkgname,
    # Ensure kernel build uses clang for host tools
    "HOSTCC": "clang",
    "CC": "clang", # Also set CC for good measure, kernel Makefiles can be complex
    "LD": "ld.lld",
    "AR": "llvm-ar",
    "NM": "llvm-nm",
    "OBJCOPY": "llvm-objcopy",
    "OBJDUMP": "llvm-objdump",
    # KBUILD_BUILD_TIMESTAMP is typically handled by the kernel's Makefile
    # using SOURCE_DATE_EPOCH set by cbuild.
}

def pre_configure(self):
    # This empty function overrides the default pre_configure behavior
    # to prevent the system script with the faulty self.do(stdout_to_file=...)
    # from running for this package.
    self.log("Skipping default pre_configure for linux-surface-generated to avoid stdout_to_file error.")
    pass
def pre_configure(self):
    # This empty function overrides the default pre_configure behavior
    # to prevent the system script with the faulty self.do(stdout_to_file=...)
    # from running for this package.
    # The main kernel patch (e.g., patch-X.Y.Z.xz) should ideally be handled
    # by cbuild's standard mechanisms if sourced correctly or applied
    # through other means if necessary (e.g. within prepare() if it were a local file).
    self.log("Skipping default pre_configure for linux-surface-generated to avoid stdout_to_file error.")
    pass
def prepare(self):
    with self.pushd(self.build_wrksrc): # self.build_wrksrc defaults to self.srcdir
        self.log("Setting localversion files...")
        # Use self.do with shell redirection for robustness
        self.do("sh", "-c", f"echo '-{self.pkgrel}' > localversion.10-pkgrel")
        self.do("sh", "-c", f"echo '{self.pkgname.replace('linux-', '')}' > localversion.20-pkgname")

        _make_vars = [
            "HOSTCC=clang", "CC=clang", "LD=ld.lld",
            "AR=llvm-ar", "NM=llvm-nm", "OBJCOPY=llvm-objcopy", "OBJDUMP=llvm-objdump"
        ]

        self.log("Running make defconfig...")
        self.do("make", *_make_vars, "defconfig")

        self.log("Running make kernelrelease...")
        kernelrelease_out = self.do("make", *_make_vars, "-s", "kernelrelease", capture_output=True, check=True)
        kernelrelease = kernelrelease_out.stdout.strip()
        # Use self.do with shell redirection for robustness
        self.do("sh", "-c", f"echo '{kernelrelease}' > version") # kernelrelease is a Python var here
        self.log(f"Kernel release: {kernelrelease}")

        self.log("Running make mrproper...")
        self.do("make", *_make_vars, "mrproper")

        self.log("Initializing git repository if needed...")
        if not (self.chroot_cwd / ".git").is_dir():
            self.do("git", "init")
            self.do("git", "config", "--local", "user.email", "cbuild@chimera-linux.org")
            self.do("git", "config", "--local", "user.name", "cbuild")
            self.do("git", "add", ".") # Add all files from extracted source
            self.do("git", "commit", "--allow-empty", "-m", "Initial cbuild commit before any patching")

        self.log("Decompressing and applying main kernel patch manually (if exists)...")
        # Assuming user renames 'patch-X.Y.Z.xz' to 'main-kernel-patch.xz' in template's 'files/' dir
        main_patch_xz_chroot_path = self.chroot_files_path / "main-kernel-patch.xz"
        main_patch_decompressed_chroot_path = self.chroot_cwd / "main_kernel.patch"

        # Check if the renamed (by user) compressed patch exists in files/
        # self.files_path is the host path to template's files/ directory
        host_main_patch_xz_path = self.files_path / "main-kernel-patch.xz"

        if host_main_patch_xz_path.exists():
            self.log(f"Found {host_main_patch_xz_path}, decompressing and applying...")
            self.do(
                "sh",
                "-c",
                f"xz -dc '{main_patch_xz_chroot_path}' > '{main_patch_decompressed_chroot_path}'"
            )
            self.do("git", "apply", "--index", "--whitespace=fix", str(main_patch_decompressed_chroot_path))
            self.do("git", "commit", "-m", f"Applied main kernel patch: {main_patch_decompressed_chroot_path.name}")
            self.log(f"Manually applied and committed {main_patch_decompressed_chroot_path.name}.")
        else:
            self.log_warn(
                f"Expected main kernel patch '{host_main_patch_xz_path}' (renamed from patch-X.Y.Z.xz) "
                "not found. Skipping manual application. "
                "If a main patch is expected, ensure it's in 'files/' and named 'main-kernel-patch.xz'."
            )

        # Now, the existing logic for patches from 'patches/' directory
        self.log("Applying patches from patches/ directory (if any)...")

        patches_dir = self.chroot_patches_path
        sorted_patches = sorted(patches_dir.glob("*.patch"))
        if not sorted_patches:
            self.log_warn("No patches found in patches/ directory.")
        for patch_file_chroot_path in sorted_patches:
            self.log(f"Applying patch {patch_file_chroot_path.name}...")
            self.do("git", "am", "-3", str(patch_file_chroot_path))

        self.log("Merging kernel configurations...")
        self.do(
            self.chroot_cwd / "scripts/kconfig/merge_config.sh", "-m",
            self.chroot_files_path / "config",        # Use self.chroot_files_path
            self.chroot_files_path / "surface.config",  # Use self.chroot_files_path
            self.chroot_files_path / "arch.config",     # Use self.chroot_files_path
            wrksrc=self.chroot_cwd
        )

        self.log("Running make olddefconfig...")
        self.do("make", *_make_vars, f"KERNELRELEASE={kernelrelease}", "olddefconfig")
        self.log(f"Prepared {self.pkgname} version {kernelrelease}")

def build(self):
    _make_vars = [ # Define again for this scope or pass from prepare if possible, for now redefine
        "HOSTCC=clang", "CC=clang", "LD=ld.lld",
        "AR=llvm-ar", "NM=llvm-nm", "OBJCOPY=llvm-objcopy", "OBJDUMP=llvm-objdump"
    ]
    with self.pushd(self.build_wrksrc):
        kernelrelease = (self.chroot_cwd / "version").read_text().strip()
        self.log(f"Building kernel version {kernelrelease}...")
        self.do("make", *_make_vars, f"KERNELRELEASE={kernelrelease}", "all")

def install(self):
    with self.pushd(self.build_wrksrc):
        kernelrelease = (self.chroot_cwd / "version").read_text().strip()
        self.log(f"Installing kernel version {kernelrelease}...")
        
        modulesdir = self.destdir / f"usr/lib/modules/{kernelrelease}"
        image_name_out = self.do("make", "-s", "image_name", capture_output=True, check=True)
        image_name = image_name_out.stdout.strip() # e.g., arch/x86/boot/bzImage

        self.install_dir(modulesdir)
        self.install_file(self.chroot_cwd / image_name, modulesdir, name="vmlinuz", mode=0o644)
        (modulesdir / "pkgbase").write_text(self.pkgname + "\n")

        self.log("Installing modules...")
        self.do(
            "make",
            f"INSTALL_MOD_PATH={self.chroot_destdir / 'usr'}",
            "DEPMOD=/doesnt/exist", # cbuild handles depmod
            "modules_install"
        )

        # Remove build and source links if they exist
        self.rm(modulesdir / "build", force=True, recursive=True)
        self.rm(modulesdir / "source", force=True, recursive=True)

        self.log("Installing files for -devel package...")
        builddir_target = modulesdir / "build"
        self.install_dir(builddir_target)

        for f_name in [".config", "Makefile", "Module.symvers", "System.map", "version", "vmlinux"]:
            f_path = self.chroot_cwd / f_name
            if f_path.exists():
                self.install_file(f_path, builddir_target, mode=0o644)
        
        for f_path_glob in self.chroot_cwd.glob("localversion.*"):
             if f_path_glob.is_file(): # Ensure it's a file
                self.install_file(f_path_glob, builddir_target, mode=0o644)

        kernel_makefile_path = self.chroot_cwd / "kernel" / "Makefile"
        if kernel_makefile_path.exists():
            self.install_dir(builddir_target / "kernel")
            self.install_file(kernel_makefile_path, builddir_target / "kernel", mode=0o644)
        
        # Assuming x86_64, adapt if other archs are targeted by the generator
        arch_makefile_path = self.chroot_cwd / "arch" / "x86" / "Makefile"
        if arch_makefile_path.exists():
            self.install_dir(builddir_target / "arch" / "x86")
            self.install_file(arch_makefile_path, builddir_target / "arch" / "x86", mode=0o644)

        for d_name in ["scripts", "include"]: # Common dirs
            src_d = self.chroot_cwd / d_name
            if src_d.is_dir():
                self.cp(src_d, builddir_target / d_name, recursive=True, symlinks=True)
        
        arch_include_path = self.chroot_cwd / "arch" / "x86" / "include" # Assuming x86_64
        if arch_include_path.is_dir():
             self.cp(arch_include_path, builddir_target / "arch" / "x86" / "include", recursive=True, symlinks=True)
        
        self.log("Installing Kconfig files...")
        for kconfig_file in self.chroot_cwd.glob("**/Kconfig*"):
            if kconfig_file.is_file():
                rel_path = kconfig_file.relative_to(self.chroot_cwd)
                target_kconfig_path = builddir_target / rel_path
                self.install_dir(target_kconfig_path.parent)
                self.install_file(kconfig_file, target_kconfig_path.parent, name=kconfig_file.name, mode=0o644)
        
        self.log("Setting up /usr/src symlink...")
        self.install_dir(self.destdir / "usr/src")
        self.ln_s(f"../lib/modules/{kernelrelease}/build", self.destdir / f"usr/src/{self.pkgname}", relative=True)

@subpackage(f"{pkgname}-devel")
def _(self):
    self.pkgdesc = f"{pkgdesc} (development files)"
    self.depends += ["clang", "pahole"] # Common devel deps
    self.options = ["foreignelf", "execstack", "!scanshlibs"] # Common options
    
    kernelrelease_real = ""
    # Determine kernelrelease from installed modules dir if possible
    # self.parent refers to the main template instance
    if hasattr(self.parent, 'destdir') and (self.parent.destdir / "usr/lib/modules").exists():
        module_paths = list((self.parent.destdir / "usr/lib/modules").glob("*"))
        if module_paths:
            kernelrelease_real = module_paths[0].name
    
    if not kernelrelease_real:
        # Fallback: try to reconstruct from pkgver if destdir isn't populated (e.g. linting)
        # This is a rough heuristic and might not be perfect if pkgver has complex suffixes.
        # The 'version' file written in prepare() is the most reliable source during actual build.
        pkgver_parts = self.parent.pkgver.split('-')[0] # Try to get "X.Y.Z" from "X.Y.Z-archthing"
        # This might need a more robust way to get the kernelrelease string if available
        # on self.parent from the prepare phase. For now, this is a placeholder.
        # A better way would be for the main 'prepare' to store 'kernelrelease' on 'self.parent.kernelrelease_val = kernelrelease'
        # and then _devel could access self.parent.kernelrelease_val.
        # However, template variables are generally read at init.
        # For now, we rely on the glob or accept it might be empty for pure lint.
        # The logging call below is part of the *generated* template.py.
        # It should use the template's self.log_warn() method.
        # self.parent.pkgver needs to be escaped with double curlies for the generator's f-string.
        self.log_warn(f"Warning: Could not reliably determine kernelrelease for -devel subpackage paths during this phase. Using pkgver: {self.parent.pkgver}")
        # A simple split might be too naive if pkgver is like "6.1.20.foo1" vs "6.1.20-arch1"
        # For now, let's assume the glob will work during actual packaging.
        # If we need a value for linting, it's tricky.
        # Let's assume for path generation, we need a value.
        # A common pattern is that the version file in build_wrksrc holds it.
        # This subpackage function runs *after* the main install.
        # The kernelrelease variable from the main scope isn't directly accessible here.
        # The glob is the most reliable way post-install.

    if kernelrelease_real:
        return [
            f"usr/lib/modules/{kernelrelease_real}/build",
            f"usr/src/{self.pkgname}"
        ]
    # If kernelrelease_real could not be determined (e.g. linting before build),
    # return an empty list or paths that might be generically checked by linter.
    # For safety, return empty if not found to avoid errors with undefined paths.
    return []

# -dbg subpackage is typically handled automatically by cbuild if !debug option is not set.
